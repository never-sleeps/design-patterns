Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

- Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.
- Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом.
- К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.

Аналогия из жизни:
- Вы планируете полететь в Рим и обойти все достопримечательности за пару дней. Но приехав, вы можете долго петлять узкими улочками, пытаясь найти Колизей.
Если у вас ограниченный бюджет — не беда. Вы можете воспользоваться виртуальным гидом, скачанным на телефон, который позволит отфильтровать только интересные вам точки. А можете плюнуть и нанять локального гида, который хоть и обойдётся в копеечку, но знает город как свои пять пальцев, и сможет посвятить вас во все городские легенды.
Таким образом, Рим выступает коллекцией достопримечательностей, а ваш мозг, навигатор или гид — итератором по коллекции. Вы, как клиентский код, можете выбрать один из итераторов, отталкиваясь от решаемой задачи и доступных ресурсов.

Структура:
- Итератор описывает интерфейс для доступа и обхода элементов коллекции.
- Конкретный итератор реализует алгоритм обхода какой-то конкретной коллекции. Объект итератора должен сам отслеживать текущую позицию при обходе коллекции, чтобы отдельные итераторы могли обходить одну и ту же коллекцию независимо.
- Коллекция описывает интерфейс получения итератора из коллекции. Как мы уже говорили, коллекции не всегда являются списком. Это может быть и база данных, и удалённое API, и что-то еще. Поэтому сама коллекция может создавать итераторы, так как она знает, какие именно итераторы способны с ней работать.
- Конкретная коллекция возвращает новый экземпляр определённого конкретного итератора, связав его с текущим объектом коллекции. Обратите внимание, что сигнатура метода возвращает интерфейс итератора. Это позволяет клиенту не зависеть от конкретных классов итераторов.
- Клиент работает со всеми объектами через интерфейсы коллекции и итератора. Так клиентский код не зависит от конкретных классов, что позволяет применять различные итераторы, не изменяя существующий код программы.
- В общем случае клиенты не создают объекты итераторов, а получают их из коллекций. Тем не менее, если клиенту требуется специальный итератор, он всегда может создать его самостоятельно.

Применимость:
- Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).
- Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
- Когда вам хочется иметь единый интерфейс обхода различных структур данных.

Преимущества:
- Упрощает классы хранения данных.
- Позволяет реализовать различные способы обхода структуры данных.
- Позволяет одновременно перемещаться по структуре данных в разные стороны.

Недостатки:
- Не оправдан, если можно обойтись простым циклом.


Пример:

    public interface Iterator {
        boolean hasNext();
        Object next();
    }
    
    public class DinerMenuIterator implements Iterator {
        MenuItem[] items;
        int position; // текущая позиция перебора в массиве
        
        public DinerMenuIterator(MenuItem[] items) { this.items = items; }
    
        //Так как в нашем примере для перебора может быть использован массив максимального размера,
        // нужно проверить не только достижение границы массива, но и равенство следующего его элемента null (признак последнего элемента)
        @Override
        public boolean hasNext() {
            return position < items.length && items[position] != null;
        }
    
        @Override
        public Object next() {
            MenuItem menuItem = items[position];
            position = position + 1;
            return menuItem;
        }
    }
    
    public class BreakfastMenuIterator implements Iterator {
        ArrayList<MenuItem> items;
        int position = 0;
    
        public BreakfastMenuIterator(ArrayList<MenuItem> items) { this.items = items; }
    
        @Override
        public boolean hasNext() {
            return position < items.size();
        }
    
        @Override
        public Object next() {
            Object object = items.get(position);
            position += 1;
            return object;
        }
    }
    
    public interface Menu {
        Iterator createIterator();
    }
    
    public class DinerMenu implements Menu {
        static final int MAX_SIZE = 6;
        int numbOfItems = 0;
        MenuItem[] menuItems;
    
        public DinerMenu() { this.menuItems = new MenuItem[MAX_SIZE]; }
    
        //Метод создаёт объект DinerMenuIterator для массива menuItems и возвращает его клиенту.
        // Клиенту не нужно знать ни то, какая коллекция menuItems хранится в DinerMenu, ни то, как реализован DinerMenuIterator.
        @Override
        public Iterator createIterator() {
            return  new DinerMenuIterator(menuItems);
        }
    }
    
    public class BreakfastMenu implements Menu {
        ArrayList<MenuItem> menuItems;
    
        public BreakfastMenu() { menuItems = new ArrayList<>(); }
    
        @Override
        public Iterator createIterator() {
            return new BreakfastMenuIterator(menuItems);
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            // Создаём меню завтраков и обедов
            Menu breakfastMenu = new BreakfastMenu();
            Menu dinerMenu = new DinerMenu();
            
            //Создаём итераторы
            Iterator breakfastMenuIterator = breakfastMenu.createIterator();
            Iterator dinerMenuIterator = dinerMenu.createIterator();
            
            // выводим результат
            System.out.println("MENU BREAKFAST:");
            printMenu(breakfastMenuIterator);
    
            System.out.println("\nMENU DINER:");
            printMenu(dinerMenuIterator);
        }
    
        public void printMenu(Iterator iterator) {
            while (iterator.hasNext()) {                    // проверяем остались ли еще элементы
                MenuItem item = (MenuItem) iterator.next(); // получаем следующий элемент
                System.out.println(item);                   // выводим данные элемента меню
            }
        }
    }

